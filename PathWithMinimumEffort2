//Binary Search + BFS

class Solution {
    public int minimumEffortPath(int[][] heights) {
        
        int left = 0;
        int right = 1000000;
        int result = right;
        
        while(left<=right){
            int mid = (left + right) / 2;
            if(canReachDestination(heights,mid)){
                result = Math.min(result, mid);
                right = mid-1;
            }
            else{
                left = mid+1;
            }
        }
        
        
        return result;
    }
    
    
    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};
    
    
    public boolean canReachDestination(int[][] heights, int mid){
        int row = heights.length;
        int col = heights[0].length;
        
        Deque<Cell> queue = new ArrayDeque<>();
        boolean[][] visited = new boolean[heights.length][heights[0].length];
        
        queue.addLast(new Cell(0,0));
        visited[0][0]=true;
        
        while(!queue.isEmpty()){
            Cell curr = queue.removeFirst();
            if(curr.x == row-1 && curr.y == col-1){
                return true;
            }
            
            for(int[] d: dir){
                int x = curr.x + d[0];
                int y = curr.y + d[1];
                
                if(isValidCell(x,y,row,col) && !visited[x][y]){
                    int currDifference = Math.abs(heights[x][y] - heights[curr.x][curr.y]);
                    if(currDifference <= mid){
                        visited[x][y] = true;
                        queue.addLast(new Cell(x,y));
                    }
                }
                
                
            }
            
            
        }
        
        return false;
        
    }
    
    public boolean isValidCell(int x, int y, int row, int col){
        return x >=0 && x <= row - 1 && y >=0 && y <= col-1;
    }
    
}

class Cell{
    int x;
    int y;
    
    Cell(int x, int y){
        this.x = x;
        this.y = y;
    }
}
